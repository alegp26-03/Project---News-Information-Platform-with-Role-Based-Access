package com.example.storeeverything.session;

import com.example.storeeverything.model.Information;
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.SessionScope;

import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID; // For generating temporary IDs

@Component
@SessionScope
public class SessionDataStore implements Serializable {

    // Stores new Information objects (before they get a DB ID).
    // Using String for temporary UUIDs as keys, or a simple counter for negative IDs.
    private Map<String, Information> newInformationMap = new HashMap<>();

    // Stores modified Information objects (existing ones from DB).
    private Map<Long, Information> modifiedInformationMap = new HashMap<>();

    // Stores IDs of Information objects marked for deletion.
    private Set<Long> deletedInformationIds = new HashSet<>();

    public Information addNewInformation(Information info) {
        // Generate a temporary unique ID for new items not yet persisted to DB
        String tempId = "temp_" + UUID.randomUUID().toString();
        // Set a temporary ID on the object, if your Information class supports it
        // Or, you can manage this mapping separately if your Information class doesn't have a temp ID field.
        // For simplicity, we'll store by this tempId in the map, and the actual ID will be generated by DB.
        newInformationMap.put(tempId, info);
        return info;
    }

    public void updateExistingInformation(Information info) {
        // Add or replace the modified version of an existing item
        modifiedInformationMap.put(info.getId(), info);
        // If an item was newly added in this session and then modified,
        // it should be treated as a modification, not a separate new item.
        // We'll remove it from the new items map if it exists there, by ID.
        newInformationMap.entrySet().removeIf(entry -> {
            Information newInfo = entry.getValue();
            return newInfo.getId() != null && newInfo.getId().equals(info.getId());
        });
    }

    public void markForDeletion(Long id) {
        deletedInformationIds.add(id);
        // Remove from new and modified maps if it was created/modified and then immediately deleted
        modifiedInformationMap.remove(id);
        newInformationMap.entrySet().removeIf(entry -> {
            Information newInfo = entry.getValue();
            return newInfo.getId() != null && newInfo.getId().equals(id);
        });
    }

    public Map<String, Information> getNewInformationMap() {
        return newInformationMap;
    }

    public Map<Long, Information> getModifiedInformationMap() {
        return modifiedInformationMap;
    }

    public Set<Long> getDeletedInformationIds() {
        return deletedInformationIds;
    }

    public void clearChanges() {
        newInformationMap.clear();
        modifiedInformationMap.clear();
        deletedInformationIds.clear();
    }
}